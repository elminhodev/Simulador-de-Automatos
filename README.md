# üßÆ Simulador de Aut√¥matos Finitos

Este reposit√≥rio cont√©m uma ferramenta desenvolvida em Python para simula√ß√£o de **aut√¥matos finitos determin√≠sticos (AFD)** e **n√£o determin√≠sticos (AFND)**, com suporte a transi√ß√µes vazias (Œµ). O projeto foi implementado em um notebook Jupyter (Google Colab) e utiliza arquivos de entrada `.aut` (defini√ß√£o do aut√¥mato) e `.in` (palavras a serem testadas).

---

## üìå Objetivo

Desenvolver um simulador de aut√¥matos finitos capaz de:

- Ler e interpretar a defini√ß√£o de aut√¥matos a partir de arquivos `.aut` no formato JSON.
- Ler palavras de entrada e seus resultados esperados a partir de arquivos `.in`.
- Simular o funcionamento do aut√¥mato passo a passo.
- Determinar se cada palavra √© **aceita** ou **rejeitada**, comparando com o resultado esperado.
- Medir o tempo de execu√ß√£o da simula√ß√£o.

---

## ‚öôÔ∏è Funcionamento

## 1. Carregar o aut√¥mato

```
def carregar_automato(nome_arquivo):
    with open(nome_arquivo, 'r') as f:
        data = json.load(f)
    inicial = data["initial"]
    finais = set(data["final"])
    transicoes = {}
    for t in data["transitions"]:
        origem = t["from"]
        simbolo = t["read"]  # pode ser None (Œµ-transi√ß√£o)
        destino = t["to"]
        transicoes.setdefault(origem, {}).setdefault(simbolo, []).append(destino)
    return inicial, finais, transicoes
```
Explica√ß√£o passo a passo:

L√™ um arquivo .aut contendo a defini√ß√£o de um aut√¥mato (em formato JSON).

Extrai:

inicial: o estado inicial (ex: "q0").

final: a lista de estados finais.

transitions: uma lista com dicion√°rios de transi√ß√µes.

Monta a estrutura de transi√ß√µes no formato:partir de q0.
```
transicoes["q0"]["a"] = ["q1"]
transicoes["q1"][None] = ["q2", "q3"]  # transi√ß√µes com Œµ (None)
```

## 2. Fun√ß√£o epsilon_closure

```
def epsilon_closure(estados, transicoes):
    pilha = list(estados)
    closure = set(estados)
    while pilha:
        estado = pilha.pop()
        for prox in transicoes.get(estado, {}).get(None, []):
            if prox not in closure:
                closure.add(prox)
                pilha.append(prox)
    return closure
```
Explica√ß√£o passo a passo:

Calcula o Œµ-fechamento: todos os estados acess√≠veis a partir de um conjunto inicial sem consumir s√≠mbolo nenhum.

A pilha serve para iterar pelos estados novos alcan√ßados via transi√ß√µes None.

Exemplo:

Se estado = "q0" e "q0" tem uma transi√ß√£o Œµ para "q1", e "q1" para "q2", a fun√ß√£o retornar√° {"q0", "q1", "q2"}.

## 3. 3. Fun√ß√£o simular_automato

```
def simular_automato(inicial, finais, transicoes, palavra):
    estados_atuais = epsilon_closure({inicial}, transicoes)
    for simbolo in palavra:
        proximos_estados = set()
        for estado in estados_atuais:
            for destino in transicoes.get(estado, {}).get(simbolo, []):
                proximos_estados.update(epsilon_closure({destino}, transicoes))
        estados_atuais = proximos_estados
    return any(estado in finais for estado in estados_atuais)
```
Explica√ß√£o passo a passo:

Come√ßa no estado inicial e calcula o Œµ-fechamento dele.

Para cada letra da palavra:

Verifica quais destinos s√£o alcan√ß√°veis a partir dos estados atuais.

Aplica Œµ-fechamento aos destinos (ap√≥s consumir o s√≠mbolo).

Ao final:

Se algum estado atual √© um estado final, a palavra √© aceita.

## 4. Fun√ß√£o executar_simulador

```
def executar_simulador():
    inicial, finais, transicoes = carregar_automato("ex3_naodeterministico.aut")
    with open("ex3_naodeterministico_input.in", 'r') as f_in, open("ex3_naodeterministico_input.out", 'w') as f_out:
        leitor = csv.reader(f_in, delimiter=';')
        for linha in leitor:
            palavra, esperado = linha[0], int(linha[1])
            inicio = time.time()
            obtido = int(simular_automato(inicial, finais, transicoes, palavra))
            tempo = round(time.time() - inicio, 3)
            f_out.write(f"{palavra};{esperado};{obtido};{tempo}\n")
```
Explica√ß√£o passo a passo:

L√™ o aut√¥mato a partir do arquivo .aut.

Abre os arquivos:

.in ‚Üí cont√©m as palavras e os resultados esperados (palavra;1 ou palavra;0).

.out ‚Üí receber√° o resultado da simula√ß√£o.

Para cada linha:

Separa a palavra e o resultado esperado.

Roda a simula√ß√£o (simular_automato).

Mede o tempo.

Escreve a sa√≠da com: palavra, esperado, resultado obtido e tempo.




